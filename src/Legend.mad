import type { Either } from "Either"
import type { Maybe } from "Maybe"

import type { Flag } from "@/Flags"

import Dict from "Dictionary"
import { Left, Right } from "Either"
import { equals, ifElse } from "Function"
import { append, isEmpty, length, reduce } from "List"
import { Just, Nothing } from "Maybe"
import String from "String"

import { Flag, FlagToggle } from "@/Flags"



export alias MatchedDictionary = {
  keyed :: Dictionary String String,
  on :: Dictionary String Boolean,
}

export type FlagKind = FString | FBoolean

// primary key, aliases
export type DeclaredFlag = DeclaredFlag(FlagKind, String, List String, String)

export flagString = DeclaredFlag(FString)
export flagBoolean = DeclaredFlag(FBoolean)

structureAliases :: String -> List String -> FlagKind -> List #[String, #[String, FlagKind]]
export structureAliases = (key, aliases, kind) => pipe(
  append(key),
  map((a) => #[a, #[key, kind]]),
)(aliases)

export alias DeclaredDictionary = Dictionary String #[String, FlagKind]

saveAliases :: List DeclaredFlag -> DeclaredDictionary
export saveAliases = pipe(
  chain(
    where {
      DeclaredFlag(kind, key, aliases, description) =>
        structureAliases(key, aliases, kind)
    },
  ),
  Dict.fromList,
)

export type Invalid = ExpectedBoolean(String) | ExpectedString(String) | UnexpectedFlag(String)

export alias PartialLegend = { ...MatchedDictionary, issues :: List Invalid }

_setOn = (agg, on) => ({ keyed: agg.keyed, issues: agg.issues, on })
_setKeyed = (agg, keyed) => ({ on: agg.on, issues: agg.issues, keyed })
_setIssues = (agg, issues) => ({ on: agg.on, keyed: agg.keyed, issues })

_handleStringAlias :: PartialLegend -> DeclaredDictionary -> String -> String -> PartialLegend
_handleStringAlias = (agg, known, key, value) => {
  addKey = (p) => pipe(
    Dict.insert(p, value),
    _setKeyed(agg),
  )(agg.keyed)
  addIssue = (cons, p) => pipe(
    cons,
    append($, agg.issues),
    _setIssues(agg),
  )(p)
  return pipe(
    Dict.get(key),
    where {
      Just(#[primary, FString]) =>
        addKey(primary)

      Just(#[primary, FBoolean]) =>
        addIssue(ExpectedBoolean, primary)

      Nothing =>
        addIssue(UnexpectedFlag, key)
    },
  )(known)
}

_handleBooleanAlias :: PartialLegend -> DeclaredDictionary -> String -> Boolean -> PartialLegend
_handleBooleanAlias = (agg, known, key, value) => {
  addOn = (p) => pipe(
    Dict.insert(p, value),
    _setOn(agg),
  )(agg.on)
  addIssue = (cons, p) => pipe(
    cons,
    append($, agg.issues),
    _setIssues(agg),
  )(p)
  return pipe(
    Dict.get(key),
    where {
      Just(#[primary, FBoolean]) =>
        addOn(primary)

      Just(#[primary, FString]) =>
        addIssue(ExpectedString, primary)

      Nothing =>
        addIssue(UnexpectedFlag, key)
    },
  )(known)
}

createLegend :: List DeclaredFlag -> List Flag -> Either (List Invalid) MatchedDictionary
export createLegend = (decls, provided) => {
  known = saveAliases(decls)
  return pipe(
    reduce(
      (agg, x) => where(x) {
        Flag(key, value) =>
          _handleStringAlias(agg, known, key, value)

        FlagToggle(key, value) =>
          _handleBooleanAlias(agg, known, key, value)
      },
      { on: {{}}, keyed: {{}}, issues: [] },
    ),
    (raw) => length(raw.issues) > 0 ? Left(raw.issues) : Right({ on: raw.on, keyed: raw.keyed }),
  )(provided)
}

flagify :: String -> String
export flagify = ifElse(
  pipe(
    String.length,
    equals(1),
  ),
  mappend("-"),
  mappend("--"),
)

_summarizeAliases :: List String -> String
_summarizeAliases = pipe(
  map(flagify),
  String.join(" / "),
)


alias DeclarationRenderer = String -> String -> List String -> String -> String

_flagBlock :: DeclarationRenderer
_flagBlock = (kind, k, als, desc) => `--${k} ${
  isEmpty(als) ? "" : "/ " ++ _summarizeAliases(als)
}\n  ${kind}\n  ${desc}`


_flagMarkdownBlock :: DeclarationRenderer
_flagMarkdownBlock = (kind, k, als, desc) => "`--"
    ++ k
    ++ "`"
    ++ `${
      isEmpty(als)
        ? ""
        : " / "
          ++ pipe(
            _summarizeAliases,
            (z) => "`" ++ z ++ "`",
          )(als)
    }\n  *${kind}*\n  ${desc}`

printWithRenderer :: DeclarationRenderer -> List DeclaredFlag -> String
export printWithRenderer = (render, x) => pipe(
  map(
    where {
      DeclaredFlag(FBoolean, k, als, desc) =>
        render("boolean", k, als, desc)

      DeclaredFlag(FString, k, als, desc) =>
        render("string", k, als, desc)
    },
  ),
  String.join("\n\n"),
)(x)

export printLegend = printWithRenderer(_flagBlock)
export printMarkdownLegend = printWithRenderer(_flagMarkdownBlock)

getFlag :: String -> MatchedDictionary -> Maybe String
export getFlag = (k, mdict) => pipe(
  .keyed,
  Dict.get(k),
)(mdict)

getToggle :: String -> MatchedDictionary -> Maybe Boolean
export getToggle = (k, mdict) => pipe(
  .on,
  Dict.get(k),
)(mdict)
