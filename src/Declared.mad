import type { Either } from "Either"

import type { Flag } from "@/Flags"

import { Left, Right } from "Either"
import { equals, ifElse } from "Function"
import { append, find, includes, isEmpty, reduce } from "List"
import { Just } from "Maybe"
import String from "String"

import { Flag, FlagToggle } from "@/Flags"



export type FlagKind = FString | FBoolean
// kind, key, aliases, description
export type DeclaredFlag = DeclaredFlag(FlagKind, String, List String, String)
export type Invalid = ExpectedBoolean(String) | ExpectedString(String) | UnexpectedFlag(String)

export alias DeclarationRenderer = String -> String -> List String -> String -> String
export alias ParsedValidation = { flags :: List Flag, issues :: List Invalid }

// constructors

export flagString = DeclaredFlag(FString)
export flagBoolean = DeclaredFlag(FBoolean)


flagify :: String -> String
export flagify = ifElse(
  pipe(
    String.length,
    equals(1),
  ),
  mappend("-"),
  mappend("--"),
)

_summarizeAliases :: List String -> String
_summarizeAliases = pipe(
  map(flagify),
  String.join(" / "),
)


_flagBlock :: DeclarationRenderer
_flagBlock = (kind, k, als, desc) => `--${k} ${
  isEmpty(als) ? "" : "/ " ++ _summarizeAliases(als)
}\n  ${kind}\n  ${desc}`


_flagMarkdownBlock :: DeclarationRenderer
_flagMarkdownBlock = (kind, k, als, desc) => "`--"
    ++ k
    ++ "`"
    ++ `${
      isEmpty(als)
        ? ""
        : " / "
          ++ pipe(
            _summarizeAliases,
            (z) => "`" ++ z ++ "`",
          )(als)
    }\n  *${kind}*\n  ${desc}`

printWithRenderer :: DeclarationRenderer -> List DeclaredFlag -> String
export printWithRenderer = (render, x) => pipe(
  map(
    where {
      DeclaredFlag(FBoolean, k, als, desc) =>
        render("boolean", k, als, desc)

      DeclaredFlag(FString, k, als, desc) =>
        render("string", k, als, desc)
    },
  ),
  String.join("\n\n"),
)(x)

export printLegend = printWithRenderer(_flagBlock)
export printMarkdownLegend = printWithRenderer(_flagMarkdownBlock)

_validKeysFromDeclaration :: List DeclaredFlag -> List #[FlagKind, List String, String]
_validKeysFromDeclaration = reduce(
  (agg, x) => where(x) {
    DeclaredFlag(kind, key, aliases, _) =>
      append(#[kind, append(key, aliases), key], agg)
  },
  [],
)

_validator = (lookup, agg, x) => {
  addIssue = (i) => ({ flags: agg.flags, issues: append(i, agg.issues) })
  addFlag = (f) => ({ issues: agg.issues, flags: append(f, agg.flags) })
  return where(x) {
    Flag(key, value) =>
      pipe(
        lookup,
        where {
          Just(#[kind, _, root]) =>
            kind == FString ? addFlag(Flag(root, value)) : addIssue(ExpectedBoolean(key))

          _ =>
            addIssue(UnexpectedFlag(key))
        },
      )(key)

    FlagToggle(key, value) =>
      pipe(
        lookup,
        where {
          Just(#[kind, _, root]) =>
            kind == FBoolean ? addFlag(FlagToggle(root, value)) : addIssue(ExpectedString(key))

          _ =>
            addIssue(UnexpectedFlag(key))
        },
      )(key)
  }
}

check :: List DeclaredFlag -> List Flag -> ParsedValidation
export check = (declared, parsed) => {
  vkeys = _validKeysFromDeclaration(declared)
  lookup = (key) => find(where { #[_, keys, _] => includes(key, keys) }, vkeys)
  return reduce(_validator(lookup), { flags: [], issues: [] }, parsed)
}

validate :: List DeclaredFlag -> List Flag -> Either (List Invalid) (List Flag)
export validate = (declared, parsed) => pipe(
  check(declared),
  (raw) => isEmpty(raw.issues) ? Right(raw.flags) : Left(raw.issues),
)(parsed)

printIssues :: List Invalid -> String
export printIssues = pipe(
  map(
    where {
      UnexpectedFlag(f) =>
        "Unexpected flag " ++ f ++ "."

      ExpectedBoolean(b) =>
        "Expected boolean flag (" ++ b ++ "), but got string."

      ExpectedString(s) =>
        "Expected string flag (" ++ s ++ "), but got boolean."
    },
  ),
  String.join("\n\t"),
  mappend("Errors during parsing.\n\t"),
)
