import type { Either } from "Either"

import type { Invalid } from "@/Declared/Flags"
import type { DeclaredFlag, FlagKind } from "@/Declared/Flags"
import type { Flag } from "@/Flags"

import { Left, Right } from "Either"
import IO from "IO"
import { append, find, includes, isEmpty, reduce } from "List"
import { Just } from "Maybe"
import String from "String"

import {
  DeclaredFlag,
  ExpectedBoolean,
  ExpectedString,
  FBoolean,
  FString,
  UnexpectedFlag,
} from "@/Declared/Flags"
import { Flag, FlagToggle } from "@/Flags"
import { camelToKebab } from "@/String"



export alias ParsedValidation = { flags :: List Flag, issues :: List Invalid }

// constructors


// export _autoConvert = (cons, primary, als, desc) => pipe(
//   camelToKebab,
//   cons($, map(camelToKebab)(als), desc),
// )(primary)

_validKeysFromDeclaration :: List DeclaredFlag -> List #[FlagKind, List String, String]
_validKeysFromDeclaration = reduce(
  (agg, x) => where(x) {
    DeclaredFlag(kind, key, aliases, _) =>
      append(#[kind, append(key, aliases), key], agg)
  },
  [],
)

_validator = (lookup, agg, x) => {
  addIssue = (i) => ({ flags: agg.flags, issues: append(i, agg.issues) })
  addFlag = (f) => ({ issues: agg.issues, flags: append(f, agg.flags) })
  return where(x) {
    Flag(key, value) =>
      pipe(
        lookup,
        where {
          Just(#[kind, _, root]) =>
            kind == FString ? addFlag(Flag(root, value)) : addIssue(ExpectedBoolean(key))

          _ =>
            addIssue(UnexpectedFlag(key))
        },
      )(key)

    FlagToggle(key, value) =>
      pipe(
        lookup,
        where {
          Just(#[kind, _, root]) =>
            kind == FBoolean ? addFlag(FlagToggle(root, value)) : addIssue(ExpectedString(key))

          _ =>
            addIssue(UnexpectedFlag(key))
        },
      )(key)
  }
}

check :: List DeclaredFlag -> List Flag -> ParsedValidation
export check = (declared, parsed) => {
  vkeys = _validKeysFromDeclaration(declared)
  lookup = (key) => find(where { #[_, keys, _] => includes(key, keys) }, vkeys)
  return reduce(_validator(lookup), { flags: [], issues: [] }, parsed)
}

validate :: List DeclaredFlag -> List Flag -> Either (List Invalid) (List Flag)
export validate = (declared, parsed) => pipe(
  check(declared),
  (raw) => isEmpty(raw.issues) ? Right(raw.flags) : Left(raw.issues),
)(parsed)
