import type { Either } from "Either"
import type { Maybe } from "Maybe"

import type { Flag } from "@/Flags"

import Dict from "Dictionary"
import { Left, Right, fromRight } from "Either"
import IO from "IO"
import { append, length, reduce } from "List"
import { Just, Nothing } from "Maybe"

import { Flag, FlagToggle } from "@/Flags"



export alias MatchedDictionary = {
  keyed :: Dictionary String String,
  on :: Dictionary String Boolean,
}

export type FlagKind = FString | FBoolean

// primary key, aliases
export type DeclaredFlag = DeclaredFlag(String, List String, FlagKind)

export aliased = DeclaredFlag
export flagString = DeclaredFlag($, $, FString)
export flagBoolean = DeclaredFlag($, $, FBoolean)

structureAliases :: String -> List String -> FlagKind -> List #[String, #[String, FlagKind]]
export structureAliases = (key, aliases, kind) => pipe(
  append(key),
  map((a) => #[a, #[key, kind]]),
)(aliases)

saveAliases :: List DeclaredFlag -> Dictionary String #[String, FlagKind]
export saveAliases = pipe(
  chain(where { DeclaredFlag(key, aliases, kind) => structureAliases(key, aliases, kind) }),
  Dict.fromList,
)

type Invalid = ExpectedBoolean(String) | ExpectedString(String) | UnexpectedFlag(String)

createLegend :: List DeclaredFlag -> List Flag -> Either (List Invalid) MatchedDictionary
export createLegend = (decls, provided) => {
  known = saveAliases(decls)
  return pipe(
    IO.pTrace("PROVIDED"),
    reduce(
      (agg, x) => {
        IO.pTrace("...issues?", agg.issues)
        return where(x) {
          Flag(key, value) =>
            where(IO.pTrace("getting " ++ key ++ "...", Dict.get(key, known))) {
              Just(#[primary, FString]) =>
                ({ on: agg.on, issues: agg.issues, keyed: Dict.insert(primary, value, agg.keyed) })

              Just(#[primary, FBoolean]) =>
                (
                  {
                    on: agg.on,
                    keyed: agg.keyed,
                    issues: append(ExpectedString(primary), agg.issues),
                  }
                )

              Nothing =>
                ({ on: agg.on, keyed: agg.keyed, issues: append(UnexpectedFlag(key), agg.issues) })
            }

          FlagToggle(key, value) =>
            where(IO.pTrace("getting " ++ key ++ "...", Dict.get(key, known))) {
              Just(#[primary, FBoolean]) =>
                ({ keyed: agg.keyed, issues: agg.issues, on: Dict.insert(primary, value, agg.on) })

              Just(#[primary, FString]) =>
                (
                  {
                    on: agg.on,
                    keyed: agg.keyed,
                    issues: append(ExpectedBoolean(primary), agg.issues),
                  }
                )

              Nothing =>
                ({ on: agg.on, keyed: agg.keyed, issues: append(UnexpectedFlag(key), agg.issues) })
            }
        }
      },
      { on: {{}}, keyed: {{}}, issues: [] },
    ),
    IO.pTrace("uhhh"),
    (raw) => length(raw.issues) > 0 ? Left(raw.issues) : Right({ on: raw.on, keyed: raw.keyed }),
  )(provided)
}

getFlag :: String -> MatchedDictionary -> Maybe String
export getFlag = (k, mdict) => pipe(
  .keyed,
  Dict.get(k),
)(mdict)

getToggle :: String -> MatchedDictionary -> Maybe Boolean
export getToggle = (k, mdict) => pipe(
  .on,
  Dict.get(k),
)(mdict)
