import type { Either } from "Either"
import type { Maybe } from "Maybe"

import type { Flag } from "@/Flags"

import Dict from "Dictionary"
import { Left, Right } from "Either"
import { append, length, reduce } from "List"
import { Just, Nothing } from "Maybe"

import { Flag, FlagToggle } from "@/Flags"



export alias MatchedDictionary = {
  keyed :: Dictionary String String,
  on :: Dictionary String Boolean,
}

export type FlagKind = FString | FBoolean

// primary key, aliases
export type DeclaredFlag = DeclaredFlag(FlagKind, String, List String, String)

export flagString = DeclaredFlag(FString)
export flagBoolean = DeclaredFlag(FBoolean)

structureAliases :: String -> List String -> FlagKind -> List #[String, #[String, FlagKind]]
export structureAliases = (key, aliases, kind) => pipe(
  append(key),
  map((a) => #[a, #[key, kind]]),
)(aliases)

export alias DeclaredDictionary = Dictionary String #[String, FlagKind]

saveAliases :: List DeclaredFlag -> DeclaredDictionary
export saveAliases = pipe(
  chain(
    where {
      DeclaredFlag(kind, key, aliases, description) =>
        structureAliases(key, aliases, kind)
    },
  ),
  Dict.fromList,
)

export type Invalid = ExpectedBoolean(String) | ExpectedString(String) | UnexpectedFlag(String)

export alias PartialLegend = { ...MatchedDictionary, issues :: List Invalid }

modifyOn = (agg, on) => ({ keyed: agg.keyed, issues: agg.issues, on })
modifyKeyed = (agg, keyed) => ({ on: agg.on, issues: agg.issues, keyed })
modifyIssues = (agg, issues) => ({ on: agg.on, keyed: agg.keyed, issues })

handleStringAlias :: PartialLegend -> DeclaredDictionary -> String -> String -> PartialLegend
handleStringAlias = (agg, known, key, value) => {
  addKey = (p) => pipe(
    Dict.insert(p, value),
    modifyKeyed(agg),
  )(agg.keyed)
  addIssue = (cons, p) => pipe(
    cons,
    append($, agg.issues),
    modifyIssues(agg),
  )(p)
  return pipe(
    Dict.get(key),
    where {
      Just(#[primary, FString]) =>
        addKey(primary)

      Just(#[primary, FBoolean]) =>
        addIssue(ExpectedBoolean, primary)

      Nothing =>
        addIssue(UnexpectedFlag, key)
    },
  )(known)
}

handleBooleanAlias :: PartialLegend -> DeclaredDictionary -> String -> Boolean -> PartialLegend
handleBooleanAlias = (agg, known, key, value) => {
  addOn = (p) => pipe(
    Dict.insert(p, value),
    modifyOn(agg),
  )(agg.on)
  addIssue = (cons, p) => pipe(
    cons,
    append($, agg.issues),
    modifyIssues(agg),
  )(p)
  return pipe(
    Dict.get(key),
    where {
      Just(#[primary, FBoolean]) =>
        addOn(primary)

      Just(#[primary, FString]) =>
        addIssue(ExpectedString, primary)

      Nothing =>
        addIssue(UnexpectedFlag, key)
    },
  )(known)
}

createLegend :: List DeclaredFlag -> List Flag -> Either (List Invalid) MatchedDictionary
export createLegend = (decls, provided) => {
  known = saveAliases(decls)
  return pipe(
    reduce(
      (agg, x) => where(x) {
        Flag(key, value) =>
          handleStringAlias(agg, known, key, value)

        FlagToggle(key, value) =>
          handleBooleanAlias(agg, known, key, value)
      },
      { on: {{}}, keyed: {{}}, issues: [] },
    ),
    (raw) => length(raw.issues) > 0 ? Left(raw.issues) : Right({ on: raw.on, keyed: raw.keyed }),
  )(provided)
}

getFlag :: String -> MatchedDictionary -> Maybe String
export getFlag = (k, mdict) => pipe(
  .keyed,
  Dict.get(k),
)(mdict)

getToggle :: String -> MatchedDictionary -> Maybe Boolean
export getToggle = (k, mdict) => pipe(
  .on,
  Dict.get(k),
)(mdict)
